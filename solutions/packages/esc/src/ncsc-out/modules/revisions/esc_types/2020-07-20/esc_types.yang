module esc_types {
  // Generated by yanger -t ncs
  tailf:mount-id esc-nc-1.0:esc-nc-1.0;
  tailf:ncs-device-type "netconf";

  namespace "http://www.cisco.com/esc/esc_types";
  prefix types;

  import ietf-inet-types {
    prefix ietf-inet-types;
  }
  import ietf-yang-types {
    prefix ietf-yang-types;
  }
  import "esc-nc-1.0" {
    prefix "esc-nc-1.0";
  }
  import tailf-ncs {
    prefix ncs;
  }
  import tailf-common {
    prefix tailf;
  }

  organization
    "Cisco Systems";
  contact
    "Shesha Sreenivasamurthy <shesha@cisco.com>";
  description
    "ESC's types declarations";

  revision 2020-07-20 {
    description
      "Added UPDATE_FLAVOR notification to event type enum";
  }
  revision 2020-07-13 {
    description
      "Added IMPORT_VM notification to event type enum";
  }
  revision 2020-04-23 {
    description
      "Added IMPORT_IMAGE_FLAVOR notification to event type enum";
  }
  revision 2019-10-09 {
    description
      "Added VM_ACTION_BLOCKED notification to event type enum";
  }
  revision 2019-10-04 {
    description
      "Added importDeploymentData action type enums";
  }
  revision 2019-02-20 {
    description
      "Added new type checksum_type";
  }
  revision 2019-02-15 {
    description
      "Added a new event types VM_MONITORING_STATUS";
  }
  revision 2019-01-07 {
    description
      "Added a new event types VM_OVERLOADED and VM_UNDERLOADED";
  }
  revision 2018-10-29 {
    description
      "Added UPDATE TENANT event type";
  }
  revision 2018-10-15 {
    description
      "Added uri";
  }
  revision 2018-09-04 {
    description
      "Added new enum config_data_format_type CONFIG_DATA_OPTIONS";
  }
  revision 2018-05-25 {
    description
      "Added new enum vim_type VMWARE_VCD";
  }
  revision 2018-05-10 {
    description
      "Added new enum vim_type KUBERNETES";
  }
  revision 2018-04-02 {
    description
      "Adding config_data_format_type to allow ESC to generate ISO files for VNF deployment.";
  }
  revision 2018-03-07 {
    description
      "Add new event type VM_NETWORK_STATE";
  }
  revision 2018-02-20 {
    description
      "Add VIM connector action types";
  }
  revision 2018-02-11 {
    description
      "Added new type host_location_type for zone_host";
  }
  revision 2018-01-25 {
    description
      "Add SET_MONITOR_AND_RECOVER in action types";
  }
  revision 2017-12-01 {
    description
      "Add checksum algorithm types";
  }
  revision 2017-10-27 {
    description
      "add backup_action_type";
  }
  revision 2017-09-25 {
    description
      "Add file server events -  CREATE, UPDATE, DELETE";
  }
  revision 2017-09-22 {
    description
      "add backup action type: export and snapshot";
  }
  revision 2017-09-21 {
    description
      "Add new event type SERVICE_RECOVERY_COMPLETE";
  }
  revision 2017-09-14 {
    description
      "fixing persistence typo";
  }
  revision 2017-09-07 {
    description
      "change snapshot event to backup";
  }
  revision 2017-07-17 {
    description
      "Add event type for VIM CONNECTION STATE , multiVIM replacement for VIM OPERATION STATE notif. VIM_OPERATIONAL_STATE is deprecated in 3.0+";
  }
  revision 2017-06-19 {
    description
      "Add event type for Default Vim Connector";
  }
  revision 2017-04-25 {
    description
      "Add snapshot event type: INIT, CREATED, COMPLETE";
  }
  revision 2017-03-30 {
    description
      "Change escnetname upperbound to 255";
  }
  revision 2017-02-27 {
    description
      "Add new event_types VOLUME_CREATE and VOLUME_DELETE for Volume API ESC callbacks";
  }
  revision 2017-01-13 {
    description
      "Removed services and service registration.";
  }
  revision 2017-01-10 {
    description
      "Service operation: deployment recovery";
  }
  revision 2016-12-02 {
    description
      "Normalize new LCS policy names";
  }
  revision 2016-11-22 {
    description
      "Make some additions and modifications to log_classification_types and log_tag_types.";
  }
  revision 2016-11-08 {
    description
      "Add new enums log_level_type and log_tag_type for filter logs api.";
  }
  revision 2016-10-06 {
    description
      "Add new new event types for vim connector and user create/delete/update.";
  }
  revision 2016-09-30 {
    description
      "Add new vim_type AWS_EC2, and update vim_type.";
  }
  revision 2016-09-23 {
    description
      "Add new enum vim_type";
  }
  revision 2016-07-21 {
    description
      "Add template_engine_type enum";
  }
  revision 2016-06-28 {
    description
      "Remove unsupported enum STRING from metric_types";
  }
  revision 2016-04-29 {
    description
      "Added a new event type VM_MANUAL_RECOVERY_NO_NEED";
  }
  revision 2016-04-13 {
    description
      "Defined a new enum policy_condition_type";
  }
  revision 2016-03-29 {
    description
      "Added a new event type VM_MANUAL_RECOVERY_NEEDED";
  }
  revision 2016-03-11 {
    description
      "Added a new style type for recovery";
  }
  revision 2016-03-01 {
    description
      "Added a new operation type for recovering on manual";
  }
  revision 2016-01-22 {
    description
      "Added a new event type VM_RECOVERY_CANCELLED and VM_RECOVERY_REBOOT";
  }
  revision 2015-11-05 {
    description
      "Remove EiB support for volumes";
  }
  revision 2015-09-21 {
    description
      "Added a leaf to config if redeploy is needed after reboot fails upon recovery";
  }
  revision 2015-08-21 {
    description
      "Removed union types for xpaths";
  }
  revision 2015-07-30 {
    description
      "Added new enum types in iface_type to support sr-iov";
  }
  revision 2015-07-24 {
    description
      "Added host_placement and zone_placement to placement_type";
  }
  revision 2015-07-23 {
    description
      "Added event type VM_UPDATED. Revision header update in data model.";
  }
  revision 2015-07-14 {
    description
      "Added VIM_OPERATIONAL_STATE and removed ESC_IN_SERVICE and ESC_OUT_OF_SERVICE.";
  }
  revision 2015-06-29 {
    description
      "ESC Types added for create/delete image/flavor";
  }
  revision 2015-06-08 {
    description
      "added types escuint8, escuint16, escuint32 for esc_port_forwarding";
  }
  revision 2014-06-23 {
    description
      "ESC Types";
  }

  typedef ncs_template_escfloat {
    type string;
    reference "http://www.w3.org/TR/xmlschema-2/#float";
  }

  typedef ncs_template_escname {
    type string;
  }

  typedef ncs_template_escversion {
    type string;
  }

  typedef ncs_template_escnetname {
    type string;
  }

  typedef ncs_template_escbigdata {
    type string;
  }

  typedef ncs_template_escipaddr {
    type string;
  }

  typedef ncs_template_esc_ip_prefix {
    type string;
  }

  typedef ncs_template_escmacaddr {
    type string;
  }

  typedef ncs_template_license_key_type {
    type string;
  }

  typedef ncs_template_license_key_value {
    type string;
  }

  typedef ncs_template_event_types {
    type string;
  }

  typedef ncs_template_status {
    type string;
  }

  typedef ncs_template_szunits {
    description
      "Some standard size units: MiB, GiB, TiB and PiB
              MiB: 1024^2 (Mebibyte)
              GiB: 1024^3 (Gibibyte)
              TiB: 1024^4 (Tebibyte)
              PiB: 1024^5 (Pebibyte)";
    type string;
  }

  typedef ncs_template_iobus {
    description
      "PCI bus interface that is to be used while attaching the OS
       disk to the domain. Currently supported bus types are IDE,
       SCSI and VIRTIO";
    type string;
  }

  typedef ncs_template_iface_type {
    description
      "Interface Type: VIRTUAL/PASSTHRU";
    type string;
  }

  typedef ncs_template_iface_model {
    description
      "Virtual Interface Type: virtio, e1000 etc. Later when we support
       'passthru' interface type we can change this to a union";
    type string;
  }

  typedef ncs_template_ipversion_t {
    description
      "ipv4 or ipv6";
    type string;
  }

  typedef ncs_template_ipprotocol_t {
    description
      "TCP or UDP";
    type string;
  }

  typedef ncs_template_disk_formats {
    description
      "The format of the disk that is being specified as disk source.
       Currently QCOW2, RAW and VMDK formats are supported.";
    type string;
  }

  typedef ncs_template_device_type {
    description
      "The type of device to be attached to the VM.
       Currently disk and cdrom are supported.";
    type string;
  }

  typedef ncs_template_conditions {
    description
      "Different conditions supported with respect to metric comparison";
    type string;
  }

  typedef ncs_template_metric_types {
    description
      "Different conditions supported with respect to metric comparison";
    type string;
  }

  typedef ncs_template_pollunits {
    description
      "Polling units, seconds or minutes";
    type string;
  }

  typedef ncs_template_wd_hardware {
    description
      "Only certain Watchdog hardware are supported current.";
    type string;
  }

  typedef ncs_template_wd_action {
    description
      "Action that should be taken by the hypervisor when watchdog
       is triggered";
    type string;
  }

  typedef ncs_template_placement_type {
    description
      "Whether VMs of two groups to be place together (affinity) or on separate
       hosts (anti_affinity), also whether VMs should be placed on a host or in a zone";
    type string;
  }

  typedef ncs_template_enforcement {
    description
      "Whether the affinity policy should be strictly or loosely enforced";
    type string;
  }

  typedef ncs_template_image_state_machine_states {
    description
      "VM state machines states";
    type string;
  }

  typedef ncs_template_flavor_state_machine_states {
    description
      "VM state machines states";
    type string;
  }

  typedef ncs_template_service_state_machine_states {
    description
      "Service state machines states";
    type string;
  }

  typedef ncs_template_vm_state_machine_states {
    description
      "VM state machines states";
    type string;
  }

  typedef ncs_template_vm_group_properties {
    description
      "vm_group_properties";
    type string;
  }

  typedef ncs_template_action_types {
    description
      "Service/VM action types";
    type string;
  }

  typedef ncs_template_vim_action_types {
    description
      "VIM connector action types";
    type string;
  }

  typedef ncs_template_recovery_action_types {
    description
      "Recovery action types";
    type string;
  }

  typedef ncs_template_recovery_style_types {
    description
      "Recovery style types";
    type string;
  }

  typedef ncs_template_recovery_op_types {
    description
      "Recovery VM operation types";
    type string;
  }

  typedef ncs_template_host_action_type {
    description
      "Host action types";
    type string;
  }

  typedef ncs_template_backup_action_type {
    description
      "backup action types";
    type string;
  }

  typedef ncs_template_log_level_types {
    description
      "Log levels that can be specified as part of filter in the filterLog rpc request.";
    type string;
  }

  typedef ncs_template_log_classification_types {
    description
      "Log classifications that can be specified as part of a filter in the filterLog rpc request.";
    type string;
  }

  typedef ncs_template_log_tag_types {
    description
      "Log tags that can be specified as part of a filter in the filterLog rpc request.";
    type string;
  }

  typedef ncs_template_life_cycle_stage_type {
    description
      "Life-cycle stage types";
    type string;
  }

  typedef ncs_template_policy_condition_type {
    description
      "Policy condition types";
    type string;
  }

  typedef ncs_template_template_engine_type {
    description
      "Config data (template file) template engine type";
    type string;
  }

  typedef ncs_template_vim_type {
    description
      "Vim types";
    type string;
  }

  typedef ncs_template_migrateAction {
    description
      "migrate Action";
    type string;
  }

  typedef ncs_template_host_location_type {
    description
      "host location path";
    type string;
  }

  typedef ncs_template_checksum_type {
    description
      "Algorithm to use to validate the image checksum";
    type string;
  }

  typedef ncs_template_file_persistence_type {
    description
      "Options for what to do with the file post operations";
    type string;
  }

  typedef ncs_template_checksum_algorithm_type {
    description
      "Supported algorithms for checksum validation";
    type string;
  }

  typedef ncs_template_service_type {
    description
      "Kubernetes Service types";
    type string;
    // NCS drop default statement
  }

  typedef ncs_template_config_data_format_type {
    description
      "Options for processing config data";
    type string;
  }

  typedef ncs_template_import_action_types {
    description
      "ImportDeploymentData action types";
    type string;
  }

  typedef ncs_template_uri {
    type string;
    description
      "The uri type represents a Uniform Resource Identifier
       (URI) as defined by STD 66.

       Objects using the uri type MUST be in US-ASCII encoding,
       and MUST be normalized as described by RFC 3986 Sections
       6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary
       percent-encoding is removed, and all case-insensitive
       characters are set to lowercase except for hexadecimal
       digits, which are normalized to uppercase as described in
       Section 6.2.2.1.

       The purpose of this normalization is to help provide
       unique URIs.  Note that this normalization is not
       sufficient to provide uniqueness.  Two URIs that are
       textually distinct after this normalization may still be
       equivalent.

       Objects using the uri type may restrict the schemes that
       they permit.  For example, 'data:' and 'urn:' schemes
       might not be appropriate.

       A zero-length URI is not a valid URI.  This can be used to
       express 'URI absent' where required.

       In the value set and its semantics, this type is equivalent
       to the Uri SMIv2 textual convention defined in RFC 5017.";
    reference
      "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax
       RFC 3305: Report from the Joint W3C/IETF URI Planning Interest
          Group: Uniform Resource Identifiers (URIs), URLs,
          and Uniform Resource Names (URNs): Clarifications
          and Recommendations
       RFC 5017: MIB Textual Conventions for Uniform Resource
          Identifiers (URIs)";
  }

  typedef ncs_rpc_notif_escfloat {
    type string;
    reference "http://www.w3.org/TR/xmlschema-2/#float";
  }

  typedef ncs_rpc_notif_escname {
    type string {
      length "1..256";
    }
  }

  typedef ncs_rpc_notif_escversion {
    type string {
      length "1..16";
    }
  }

  typedef ncs_rpc_notif_escnetname {
    type string {
      length "1..255";
    }
  }

  typedef ncs_rpc_notif_escbigdata {
    type string {
      length "1..16384";
    }
  }

  typedef ncs_rpc_notif_escipaddr {
    type ietf-inet-types:ip-address;
  }

  typedef ncs_rpc_notif_esc_ip_prefix {
    type string {
      pattern '(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8]))';
    }
  }

  typedef ncs_rpc_notif_escmacaddr {
    type ietf-yang-types:mac-address;
  }

  typedef ncs_rpc_notif_license_key_type {
    type enumeration {
      enum "mac_addr";
    }
  }

  typedef ncs_rpc_notif_license_key_value {
    type string {
      length "1..256";
    }
  }

  typedef ncs_rpc_notif_event_types {
    type enumeration {
      enum "CREATE_NETWORK";
      enum "DELETE_NETWORK";
      enum "CREATE_SUBNET";
      enum "DELETE_SUBNET";
      enum "CREATE_TENANT";
      enum "DELETE_TENANT";
      enum "CREATE_IMAGE";
      enum "DELETE_IMAGE";
      enum "CREATE_FLAVOR";
      enum "DELETE_FLAVOR";
      enum "VM_DEPLOYED";
      enum "VM_ALIVE";
      enum "VM_UPDATED";
      enum "VM_UNDEPLOYED";
      enum "SERVICE_ALIVE";
      enum "SERVICE_UNDEPLOYED";
      enum "VM_SCALE_OUT_INIT";
      enum "VM_SCALE_OUT_DEPLOYED";
      enum "VM_SCALE_OUT_COMPLETE";
      enum "VM_SCALE_IN_INIT";
      enum "VM_SCALE_IN_COMPLETE";
      enum "VM_RECOVERY_INIT";
      enum "VM_RECOVERY_DEPLOYED";
      enum "VM_RECOVERY_UNDEPLOYED";
      enum "VM_RECOVERY_COMPLETE";
      enum "SERVICE_UPDATED";
      enum "VM_STOPPED";
      enum "SERVICE_STOPPED";
      enum "VM_STARTED";
      enum "SERVICE_STARTED";
      enum "VM_REBOOTED";
      enum "SERVICE_REBOOTED";
      enum "VM_MONITOR_UNSET";
      enum "SERVICE_MONITOR_UNSET";
      enum "VM_MONITOR_SET";
      enum "VIM_OPERATIONAL_STATE";
      enum "VM_RECOVERY_CANCELLED";
      enum "VM_RECOVERY_REBOOT";
      enum "HOST_ENABLE";
      enum "HOST_DISABLE";
      enum "VM_MANUAL_RECOVERY_NEEDED";
      enum "VM_MANUAL_RECOVERY_NO_NEED";
      enum "CREATE_VIM_CONNECTOR";
      enum "DELETE_VIM_CONNECTOR";
      enum "UPDATE_VIM_CONNECTOR";
      enum "CREATE_VIM_USER";
      enum "DELETE_VIM_USER";
      enum "UPDATE_VIM_USER";
      enum "VM_SOFTWARE_VERSION_UPDATED";
      enum "LCS_NOTIFY";
      enum "CREATE_VOLUME";
      enum "DELETE_VOLUME";
      enum "VM_BACKUP_INIT";
      enum "VM_BACKUP_CREATED";
      enum "VM_BACKUP_COMPLETE";
      enum "CREATE_DEFAULT_VIM_CONNECTOR";
      enum "DELETE_DEFAULT_VIM_CONNECTOR";
      enum "UPDATE_DEFAULT_VIM_CONNECTOR";
      enum "VIM_CONNECTION_STATE";
      enum "SERVICE_RECOVERY_COMPLETE";
      enum "CREATE_FILE_SERVER";
      enum "UPDATE_FILE_SERVER";
      enum "DELETE_FILE_SERVER";
      enum "VM_NETWORK_STATE";
      enum "UPDATE_TENANT";
      enum "VM_OVERLOADED";
      enum "VM_UNDERLOADED";
      enum "VM_MONITORING_STATUS";
      enum "POLICY_ACTION_UPDATE";
      enum "VM_ACTION_BLOCKED";
      enum "SUBNET_UPDATED";
      enum "VM_MIGRATE_INIT";
      enum "VM_MIGRATED";
      enum "VM_MIGRATE_COMPLETE";
      enum "IMAGE_UPDATED";
      enum "EXPORT_IMAGE_FLAVOR";
      enum "IMPORT_IMAGE_FLAVOR";
      enum "UPDATE_CONFIG_PARAM";
      enum "DELETE_CONFIG_PARAM";
      enum "IMPORT_VM";
      enum "UPDATE_FLAVOR";
    }
  }

  typedef ncs_rpc_notif_status {
    type enumeration {
      enum "SUCCESS";
      enum "FAILURE";
    }
  }

  typedef ncs_rpc_notif_szunits {
    description
      "Some standard size units: MiB, GiB, TiB and PiB
              MiB: 1024^2 (Mebibyte)
              GiB: 1024^3 (Gibibyte)
              TiB: 1024^4 (Tebibyte)
              PiB: 1024^5 (Pebibyte)";
    type enumeration {
      enum "MiB";
      enum "GiB";
      enum "TiB";
      enum "PiB";
    }
  }

  typedef ncs_rpc_notif_iobus {
    description
      "PCI bus interface that is to be used while attaching the OS
       disk to the domain. Currently supported bus types are IDE,
       SCSI and VIRTIO";
    type enumeration {
      enum "ide";
      enum "scsi";
      enum "virtio";
    }
  }

  typedef ncs_rpc_notif_iface_type {
    description
      "Interface Type: VIRTUAL/PASSTHRU";
    type enumeration {
      enum "virtual";
      enum "passthru";
      enum "direct";
      enum "macvtap";
      enum "access";
      enum "trunk";
    }
  }

  typedef ncs_rpc_notif_iface_model {
    description
      "Virtual Interface Type: virtio, e1000 etc. Later when we support
       'passthru' interface type we can change this to a union";
    type enumeration {
      enum "e1000";
      enum "ne2k_pci";
      enum "virtio";
      enum "i82551";
      enum "i82557b";
      enum "i82559er";
      enum "rtl8139";
      enum "pcnet";
    }
  }

  typedef ncs_rpc_notif_ipversion_t {
    description
      "ipv4 or ipv6";
    type enumeration {
      enum "ipv4";
      enum "ipv6";
    }
  }

  typedef ncs_rpc_notif_ipprotocol_t {
    description
      "TCP or UDP";
    type enumeration {
      enum "TCP";
      enum "UDP";
    }
  }

  typedef ncs_rpc_notif_disk_formats {
    description
      "The format of the disk that is being specified as disk source.
       Currently QCOW2, RAW and VMDK formats are supported.";
    type enumeration {
      enum "qcow2";
      enum "raw";
      enum "vmdk";
    }
  }

  typedef ncs_rpc_notif_device_type {
    description
      "The type of device to be attached to the VM.
       Currently disk and cdrom are supported.";
    type enumeration {
      enum "disk";
      enum "cdrom";
    }
  }

  typedef ncs_rpc_notif_conditions {
    description
      "Different conditions supported with respect to metric comparison";
    type enumeration {
      enum "GT";
      enum "LT";
      enum "EQ";
      enum "GE";
      enum "LE";
    }
  }

  typedef ncs_rpc_notif_metric_types {
    description
      "Different conditions supported with respect to metric comparison";
    type enumeration {
      enum "INT8";
      enum "INT16";
      enum "INT32";
      enum "UINT8";
      enum "UINT16";
      enum "UINT32";
      enum "FLOAT";
      enum "DOUBLE";
    }
  }

  typedef ncs_rpc_notif_pollunits {
    description
      "Polling units, seconds or minutes";
    type enumeration {
      enum "minutes";
      enum "seconds";
    }
  }

  typedef ncs_rpc_notif_wd_hardware {
    description
      "Only certain Watchdog hardware are supported current.";
    type enumeration {
      enum "i6300esb";
      enum "ib700";
    }
  }

  typedef ncs_rpc_notif_wd_action {
    description
      "Action that should be taken by the hypervisor when watchdog
       is triggered";
    type enumeration {
      enum "reset";
      enum "poweroff";
      enum "shutdown";
      enum "pasue";
      enum "debug";
      enum "none";
    }
  }

  typedef ncs_rpc_notif_placement_type {
    description
      "Whether VMs of two groups to be place together (affinity) or on separate
       hosts (anti_affinity), also whether VMs should be placed on a host or in a zone";
    type enumeration {
      enum "affinity";
      enum "anti_affinity";
      enum "zone_host";
    }
  }

  typedef ncs_rpc_notif_enforcement {
    description
      "Whether the affinity policy should be strictly or loosely enforced";
    type enumeration {
      enum "strict";
    }
  }

  typedef ncs_rpc_notif_image_state_machine_states {
    description
      "VM state machines states";
    type enumeration {
      enum "IMAGE_UNDEF_STATE";
      enum "IMAGE_CREATING_STATE";
      enum "IMAGE_ACTIVE_STATE";
      enum "IMAGE_DELETING_STATE";
      enum "IMAGE_DELETED_STATE";
      enum "IMAGE_ERROR_STATE";
    }
  }

  typedef ncs_rpc_notif_flavor_state_machine_states {
    description
      "VM state machines states";
    type enumeration {
      enum "FLAVOR_UNDEF_STATE";
      enum "FLAVOR_CREATING_STATE";
      enum "FLAVOR_ACTIVE_STATE";
      enum "FLAVOR_DELETING_STATE";
      enum "FLAVOR_DELETED_STATE";
      enum "FLAVOR_ERROR_STATE";
    }
  }

  typedef ncs_rpc_notif_service_state_machine_states {
    description
      "Service state machines states";
    type enumeration {
      enum "SERVICE_UNDEF_STATE";
      enum "SERVICE_DEPLOYING_STATE";
      enum "SERVICE_INERT_STATE";
      enum "SERVICE_ACTIVE_STATE";
      enum "SERVICE_UNDEPLOYING_STATE";
      enum "SERVICE_STOPPING_STATE";
      enum "SERVICE_STOPPED_STATE";
      enum "SERVICE_STARTING_STATE";
      enum "SERVICE_REBOOTING_STATE";
      enum "SERVICE_ERROR_STATE";
    }
  }

  typedef ncs_rpc_notif_vm_state_machine_states {
    description
      "VM state machines states";
    type enumeration {
      enum "VM_UNDEF_STATE";
      enum "VM_DEPLOYING_STATE";
      enum "VM_MONITOR_UNSET_STATE";
      enum "VM_MONITOR_DISABLED_STATE";
      enum "VM_STOPPING_STATE";
      enum "VM_SHUTOFF_STATE";
      enum "VM_STARTING_STATE";
      enum "VM_REBOOTING_STATE";
      enum "VM_INERT_STATE";
      enum "VM_ALIVE_STATE";
      enum "VM_UNDEPLOYING_STATE";
      enum "VM_ERROR_STATE";
    }
  }

  typedef ncs_rpc_notif_vm_group_properties {
    description
      "vm_group_properties";
    type enumeration {
      enum "NOTIFY_EXTERNAL_MONITOR";
    }
  }

  typedef ncs_rpc_notif_action_types {
    description
      "Service/VM action types";
    type enumeration {
      enum "STOP";
      enum "START";
      enum "REBOOT";
      enum "DISABLE_MONITOR";
      enum "ENABLE_MONITOR";
      enum "DEPLOYMENT_RECOVERY";
      enum "RECOVER";
      enum "SET_MONITOR_AND_RECOVER";
    }
  }

  typedef ncs_rpc_notif_vim_action_types {
    description
      "VIM connector action types";
    type enumeration {
      enum "CHECK_STATUS";
    }
  }

  typedef ncs_rpc_notif_recovery_action_types {
    description
      "Recovery action types";
    type enumeration {
      enum "REBOOT_THEN_REDEPLOY";
      enum "REBOOT_ONLY";
      enum "REDEPLOY_ONLY";
    }
  }

  typedef ncs_rpc_notif_recovery_style_types {
    description
      "Recovery style types";
    type enumeration {
      enum "AUTO";
      enum "MANUAL";
    }
  }

  typedef ncs_rpc_notif_recovery_op_types {
    description
      "Recovery VM operation types";
    type enumeration {
      enum "DO";
      enum "DONOT";
    }
  }

  typedef ncs_rpc_notif_host_action_type {
    description
      "Host action types";
    type enumeration {
      enum "ENABLE";
      enum "DISABLE";
    }
  }

  typedef ncs_rpc_notif_backup_action_type {
    description
      "backup action types";
    type enumeration {
      enum "EXPORT";
      enum "SNAPSHOT";
    }
  }

  typedef ncs_rpc_notif_log_level_types {
    description
      "Log levels that can be specified as part of filter in the filterLog rpc request.";
    type enumeration {
      enum "ERROR";
      enum "INFO";
      enum "WARN";
      enum "TRACE";
      enum "DEBUG";
      enum "FATAL";
    }
  }

  typedef ncs_rpc_notif_log_classification_types {
    description
      "Log classifications that can be specified as part of a filter in the filterLog rpc request.";
    type enumeration {
      enum "NBI";
      enum "SBI";
      enum "SM";
      enum "MONITORING";
      enum "DYNAMIC_MAPPING";
      enum "CONFD";
      enum "CONFD_NOTIFICATION";
      enum "OS";
      enum "LIBVIRT";
      enum "VIM";
      enum "REST_EVENT";
      enum "WD";
      enum "DM";
      enum "DB";
      enum "GW";
      enum "LC";
      enum "SEC";
      enum "MOCONFIG";
      enum "POLICY";
      enum "TP";
      enum "ESC";
    }
  }

  typedef ncs_rpc_notif_log_tag_types {
    description
      "Log tags that can be specified as part of a filter in the filterLog rpc request.";
    type enumeration {
      enum "wf";
      enum "eventType";
      enum "tenant";
      enum "network";
      enum "subnet";
      enum "user";
      enum "image";
      enum "flavor";
      enum "depName";
      enum "vmGrpName";
      enum "vmName";
      enum "switch";
      enum "volumeId";
      enum "svcName";
      enum "escTransactionId";
      enum "externalTenantId";
      enum "internalTenantId";
      enum "operationType";
      enum "threadName";
      enum "stateMachineContextId";
      enum "stateMachineType";
    }
  }

  typedef ncs_rpc_notif_life_cycle_stage_type {
    description
      "Life-cycle stage types";
    type enumeration {
      enum "PRE_DEP";
      enum "POST_DEP";
      enum "DEP_ERROR";
      enum "PRE_UNDEP";
      enum "POST_UNDEP";
      enum "VM_RECOVERY_ERROR";
      enum "VM_RECOVERY_REDEPLOY_ERROR";
    }
  }

  typedef ncs_rpc_notif_policy_condition_type {
    description
      "Policy condition types";
    type enumeration {
      enum "LCS::PRE_DEPLOY";
      enum "LCS::POST_DEPLOY_ALIVE";
      enum "LCS::DEPLOY_ERR";
      enum "LCS::POST_DEPLOY::VM_RECOVERY_ERR";
      enum "LCS::POST_DEPLOY::VM_RECOVERY_REDEPLOY_ERR";
      enum "LCS::DEPLOY::PRE_SERVICE_DEPLOY_INIT";
      enum "LCS::DEPLOY::PRE_VM_DEPLOY";
      enum "LCS::DEPLOY::POST_VM_DEPLOYED";
      enum "LCS::DEPLOY::POST_VM_DEPLOY_ERR";
      enum "LCS::DEPLOY::POST_VM_ALIVE";
      enum "LCS::DEPLOY::POST_SERVICE_DEPLOYED";
      enum "LCS::DEPLOY::POST_SERVICE_DEPLOY_ERR";
      enum "LCS::DEPLOY_UPDATE::PRE_SERVICE_UPDATE_INIT";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_DEPLOY";
      enum "LCS::DEPLOY_UPDATE::POST_VM_DEPLOYED";
      enum "LCS::DEPLOY_UPDATE::POST_VM_DEPLOY_ERR";
      enum "LCS::DEPLOY_UPDATE::POST_VM_ALIVE";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_UPDATE";
      enum "LCS::DEPLOY_UPDATE::POST_VM_UPDATED";
      enum "LCS::DEPLOY_UPDATE::POST_VM_UPDATE_ERR";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_UNDEPLOY";
      enum "LCS::DEPLOY_UPDATE::POST_VM_UNDEPLOYED";
      enum "LCS::DEPLOY_UPDATE::POST_SERVICE_UPDATED";
      enum "LCS::DEPLOY_UPDATE::POST_SERVICE_UPDATE_ERR";
      enum "LCS::UNDEPLOY::PRE_SERVICE_UNDEPLOY_INIT";
      enum "LCS::UNDEPLOY::PRE_VM_UNDEPLOY";
      enum "LCS::UNDEPLOY::POST_VM_UNDEPLOYED";
      enum "LCS::UNDEPLOY::POST_VM_UNDEPLOY_ERR";
      enum "LCS::UNDEPLOY::POST_SERVICE_UNDEPLOYED";
      enum "LCS::UNDEPLOY::POST_SERVICE_UNDEPLOY_ERR";
      enum "LCS::POST_DEPLOY::PRE_VM_RECOVERY_INIT";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_REBOOTED";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_DEPLOYED";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_COMPLETE";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_ERR";
      enum "LCS::POST_DEPLOY::PRE_VM_RECOVERY_REDEPLOY_INIT";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_REDEPLOY_DEPLOYED";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_REDEPLOY_COMPLETE";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_REDEPLOY_ERR";
      enum "LCS::VM_SCALE_OUT::PRE_VM_SCALE_OUT_INIT";
      enum "LCS::VM_SCALE_OUT::PRE_VM_DEPLOY";
      enum "LCS::VM_SCALE_OUT::POST_VM_DEPLOYED";
      enum "LCS::VM_SCALE_OUT::POST_VM_DEPLOY_ERR";
      enum "LCS::VM_SCALE_OUT::POST_VM_ALIVE";
      enum "LCS::VM_SCALE_OUT::POST_VM_SCALE_OUT_COMPLETE";
      enum "LCS::VM_SCALE_OUT::POST_VM_SCALE_OUT_ERR";
      enum "LCS::VM_SCALE_IN::PRE_VM_SCALE_IN_INIT";
      enum "LCS::VM_SCALE_IN::PRE_VM_UNDEPLOY";
      enum "LCS::VM_SCALE_IN::POST_VM_UNDEPLOYED";
      enum "LCS::VM_SCALE_IN::POST_VM_UNDEPLOY_ERR";
      enum "LCS::VM_SCALE_IN::POST_VM_SCALE_IN_COMPLETE";
      enum "LCS::VM_SCALE_IN::POST_VM_SCALE_IN_ERR";
      enum "LCS::VM::PRE_VM_DEPLOY";
      enum "LCS::VM::POST_VM_DEPLOYED";
      enum "LCS::VM::POST_VM_DEPLOY_ERR";
      enum "LCS::VM::POST_VM_ALIVE";
      enum "LCS::VM::PRE_VM_UNDEPLOY";
      enum "LCS::VM::POST_VM_UNDEPLOYED";
      enum "LCS::VM::POST_VM_UNDEPLOY_ERR";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_SOFTWARE_VERSION_UPDATE";
      enum "LCS::DEPLOY_UPDATE::POST_VM_SOFTWARE_VERSION_UPDATED";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_VOLUME_DETACH";
      enum "LCS::DEPLOY_UPDATE::POST_VM_VOLUME_DETACHED";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_VOLUME_ATTACH";
      enum "LCS::DEPLOY_UPDATE::POST_VM_VOLUME_ATTACHED";
    }
  }

  typedef ncs_rpc_notif_template_engine_type {
    description
      "Config data (template file) template engine type";
    type enumeration {
      enum "VELOCITY";
      enum "NONE";
    }
  }

  typedef ncs_rpc_notif_vim_type {
    description
      "Vim types";
    type enumeration {
      enum "OPENSTACK";
      enum "LIBVIRT";
      enum "VMWARE_VSPHERE";
      enum "AWS_EC2";
      enum "CSP";
      enum "KUBERNETES";
      enum "VMWARE_VCD";
      enum "CCP";
      enum "DOCKER";
    }
  }

  typedef ncs_rpc_notif_migrateAction {
    description
      "migrate Action";
    type enumeration {
      enum "enabledpdk";
    }
  }

  typedef ncs_rpc_notif_host_location_type {
    description
      "host location path";
    type string {
      pattern '[a-zA-Z0-9:.\-_]*';
      length "1..256";
    }
  }

  typedef ncs_rpc_notif_checksum_type {
    description
      "Algorithm to use to validate the image checksum";
    type enumeration {
      enum "sha256sum";
      enum "sha512sum";
    }
  }

  typedef ncs_rpc_notif_file_persistence_type {
    description
      "Options for what to do with the file post operations";
    type enumeration {
      enum "CACHE" {
        description
          "Keep local copy";
      }
      enum "FETCH_ALWAYS" {
        description
          "Fetch file each time it is used";
      }
      enum "FETCH_MISSING" {
        description
          "Use local copy or fetch if missing";
      }
    }
  }

  typedef ncs_rpc_notif_checksum_algorithm_type {
    description
      "Supported algorithms for checksum validation";
    type enumeration {
      enum "MD5";
      enum "SHA1";
      enum "SHA224";
      enum "SHA256";
      enum "SHA384";
      enum "SHA512";
    }
  }

  typedef ncs_rpc_notif_service_type {
    description
      "Kubernetes Service types";
    type enumeration {
      enum "LoadBalancer";
      enum "ClusterIP";
      enum "NodePort";
    }
    default "ClusterIP";
  }

  typedef ncs_rpc_notif_config_data_format_type {
    description
      "Options for processing config data";
    type enumeration {
      enum "CREATE_ISO" {
        description
          "Create an ISO file using the files provided and upload to VM";
      }
      enum "CONFIG_DATA_OPTIONS" {
        description
          "Config data options like additional day-0 configurations";
      }
    }
  }

  typedef ncs_rpc_notif_import_action_types {
    description
      "ImportDeploymentData action types";
    type enumeration {
      enum "CREATE";
      enum "DELETE";
      enum "GET";
      enum "FINALIZE";
    }
  }

  typedef ncs_rpc_notif_uri {
    type string;
    description
      "The uri type represents a Uniform Resource Identifier
       (URI) as defined by STD 66.

       Objects using the uri type MUST be in US-ASCII encoding,
       and MUST be normalized as described by RFC 3986 Sections
       6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary
       percent-encoding is removed, and all case-insensitive
       characters are set to lowercase except for hexadecimal
       digits, which are normalized to uppercase as described in
       Section 6.2.2.1.

       The purpose of this normalization is to help provide
       unique URIs.  Note that this normalization is not
       sufficient to provide uniqueness.  Two URIs that are
       textually distinct after this normalization may still be
       equivalent.

       Objects using the uri type may restrict the schemes that
       they permit.  For example, 'data:' and 'urn:' schemes
       might not be appropriate.

       A zero-length URI is not a valid URI.  This can be used to
       express 'URI absent' where required.

       In the value set and its semantics, this type is equivalent
       to the Uri SMIv2 textual convention defined in RFC 5017.";
    reference
      "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax
       RFC 3305: Report from the Joint W3C/IETF URI Planning Interest
          Group: Uniform Resource Identifiers (URIs), URLs,
          and Uniform Resource Names (URNs): Clarifications
          and Recommendations
       RFC 5017: MIB Textual Conventions for Uniform Resource
          Identifiers (URIs)";
  }

  typedef live_ncs_escfloat {
    type string;
    reference "http://www.w3.org/TR/xmlschema-2/#float";
  }

  typedef live_ncs_escname {
    type string {
      length "1..256";
    }
  }

  typedef live_ncs_escversion {
    type string {
      length "1..16";
    }
  }

  typedef live_ncs_escnetname {
    type string {
      length "1..255";
    }
  }

  typedef live_ncs_escbigdata {
    type string {
      length "1..16384";
    }
  }

  typedef live_ncs_escipaddr {
    type ietf-inet-types:ip-address;
  }

  typedef live_ncs_esc_ip_prefix {
    type string {
      pattern '(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8]))';
    }
  }

  typedef live_ncs_escmacaddr {
    type ietf-yang-types:mac-address;
  }

  typedef live_ncs_license_key_type {
    type enumeration {
      enum "mac_addr";
    }
  }

  typedef live_ncs_license_key_value {
    type string {
      length "1..256";
    }
  }

  typedef live_ncs_event_types {
    type enumeration {
      enum "CREATE_NETWORK";
      enum "DELETE_NETWORK";
      enum "CREATE_SUBNET";
      enum "DELETE_SUBNET";
      enum "CREATE_TENANT";
      enum "DELETE_TENANT";
      enum "CREATE_IMAGE";
      enum "DELETE_IMAGE";
      enum "CREATE_FLAVOR";
      enum "DELETE_FLAVOR";
      enum "VM_DEPLOYED";
      enum "VM_ALIVE";
      enum "VM_UPDATED";
      enum "VM_UNDEPLOYED";
      enum "SERVICE_ALIVE";
      enum "SERVICE_UNDEPLOYED";
      enum "VM_SCALE_OUT_INIT";
      enum "VM_SCALE_OUT_DEPLOYED";
      enum "VM_SCALE_OUT_COMPLETE";
      enum "VM_SCALE_IN_INIT";
      enum "VM_SCALE_IN_COMPLETE";
      enum "VM_RECOVERY_INIT";
      enum "VM_RECOVERY_DEPLOYED";
      enum "VM_RECOVERY_UNDEPLOYED";
      enum "VM_RECOVERY_COMPLETE";
      enum "SERVICE_UPDATED";
      enum "VM_STOPPED";
      enum "SERVICE_STOPPED";
      enum "VM_STARTED";
      enum "SERVICE_STARTED";
      enum "VM_REBOOTED";
      enum "SERVICE_REBOOTED";
      enum "VM_MONITOR_UNSET";
      enum "SERVICE_MONITOR_UNSET";
      enum "VM_MONITOR_SET";
      enum "VIM_OPERATIONAL_STATE";
      enum "VM_RECOVERY_CANCELLED";
      enum "VM_RECOVERY_REBOOT";
      enum "HOST_ENABLE";
      enum "HOST_DISABLE";
      enum "VM_MANUAL_RECOVERY_NEEDED";
      enum "VM_MANUAL_RECOVERY_NO_NEED";
      enum "CREATE_VIM_CONNECTOR";
      enum "DELETE_VIM_CONNECTOR";
      enum "UPDATE_VIM_CONNECTOR";
      enum "CREATE_VIM_USER";
      enum "DELETE_VIM_USER";
      enum "UPDATE_VIM_USER";
      enum "VM_SOFTWARE_VERSION_UPDATED";
      enum "LCS_NOTIFY";
      enum "CREATE_VOLUME";
      enum "DELETE_VOLUME";
      enum "VM_BACKUP_INIT";
      enum "VM_BACKUP_CREATED";
      enum "VM_BACKUP_COMPLETE";
      enum "CREATE_DEFAULT_VIM_CONNECTOR";
      enum "DELETE_DEFAULT_VIM_CONNECTOR";
      enum "UPDATE_DEFAULT_VIM_CONNECTOR";
      enum "VIM_CONNECTION_STATE";
      enum "SERVICE_RECOVERY_COMPLETE";
      enum "CREATE_FILE_SERVER";
      enum "UPDATE_FILE_SERVER";
      enum "DELETE_FILE_SERVER";
      enum "VM_NETWORK_STATE";
      enum "UPDATE_TENANT";
      enum "VM_OVERLOADED";
      enum "VM_UNDERLOADED";
      enum "VM_MONITORING_STATUS";
      enum "POLICY_ACTION_UPDATE";
      enum "VM_ACTION_BLOCKED";
      enum "SUBNET_UPDATED";
      enum "VM_MIGRATE_INIT";
      enum "VM_MIGRATED";
      enum "VM_MIGRATE_COMPLETE";
      enum "IMAGE_UPDATED";
      enum "EXPORT_IMAGE_FLAVOR";
      enum "IMPORT_IMAGE_FLAVOR";
      enum "UPDATE_CONFIG_PARAM";
      enum "DELETE_CONFIG_PARAM";
      enum "IMPORT_VM";
      enum "UPDATE_FLAVOR";
    }
  }

  typedef live_ncs_status {
    type enumeration {
      enum "SUCCESS";
      enum "FAILURE";
    }
  }

  typedef live_ncs_szunits {
    description
      "Some standard size units: MiB, GiB, TiB and PiB
              MiB: 1024^2 (Mebibyte)
              GiB: 1024^3 (Gibibyte)
              TiB: 1024^4 (Tebibyte)
              PiB: 1024^5 (Pebibyte)";
    type enumeration {
      enum "MiB";
      enum "GiB";
      enum "TiB";
      enum "PiB";
    }
  }

  typedef live_ncs_iobus {
    description
      "PCI bus interface that is to be used while attaching the OS
       disk to the domain. Currently supported bus types are IDE,
       SCSI and VIRTIO";
    type enumeration {
      enum "ide";
      enum "scsi";
      enum "virtio";
    }
  }

  typedef live_ncs_iface_type {
    description
      "Interface Type: VIRTUAL/PASSTHRU";
    type enumeration {
      enum "virtual";
      enum "passthru";
      enum "direct";
      enum "macvtap";
      enum "access";
      enum "trunk";
    }
  }

  typedef live_ncs_iface_model {
    description
      "Virtual Interface Type: virtio, e1000 etc. Later when we support
       'passthru' interface type we can change this to a union";
    type enumeration {
      enum "e1000";
      enum "ne2k_pci";
      enum "virtio";
      enum "i82551";
      enum "i82557b";
      enum "i82559er";
      enum "rtl8139";
      enum "pcnet";
    }
  }

  typedef live_ncs_ipversion_t {
    description
      "ipv4 or ipv6";
    type enumeration {
      enum "ipv4";
      enum "ipv6";
    }
  }

  typedef live_ncs_ipprotocol_t {
    description
      "TCP or UDP";
    type enumeration {
      enum "TCP";
      enum "UDP";
    }
  }

  typedef live_ncs_disk_formats {
    description
      "The format of the disk that is being specified as disk source.
       Currently QCOW2, RAW and VMDK formats are supported.";
    type enumeration {
      enum "qcow2";
      enum "raw";
      enum "vmdk";
    }
  }

  typedef live_ncs_device_type {
    description
      "The type of device to be attached to the VM.
       Currently disk and cdrom are supported.";
    type enumeration {
      enum "disk";
      enum "cdrom";
    }
  }

  typedef live_ncs_conditions {
    description
      "Different conditions supported with respect to metric comparison";
    type enumeration {
      enum "GT";
      enum "LT";
      enum "EQ";
      enum "GE";
      enum "LE";
    }
  }

  typedef live_ncs_metric_types {
    description
      "Different conditions supported with respect to metric comparison";
    type enumeration {
      enum "INT8";
      enum "INT16";
      enum "INT32";
      enum "UINT8";
      enum "UINT16";
      enum "UINT32";
      enum "FLOAT";
      enum "DOUBLE";
    }
  }

  typedef live_ncs_pollunits {
    description
      "Polling units, seconds or minutes";
    type enumeration {
      enum "minutes";
      enum "seconds";
    }
  }

  typedef live_ncs_wd_hardware {
    description
      "Only certain Watchdog hardware are supported current.";
    type enumeration {
      enum "i6300esb";
      enum "ib700";
    }
  }

  typedef live_ncs_wd_action {
    description
      "Action that should be taken by the hypervisor when watchdog
       is triggered";
    type enumeration {
      enum "reset";
      enum "poweroff";
      enum "shutdown";
      enum "pasue";
      enum "debug";
      enum "none";
    }
  }

  typedef live_ncs_placement_type {
    description
      "Whether VMs of two groups to be place together (affinity) or on separate
       hosts (anti_affinity), also whether VMs should be placed on a host or in a zone";
    type enumeration {
      enum "affinity";
      enum "anti_affinity";
      enum "zone_host";
    }
  }

  typedef live_ncs_enforcement {
    description
      "Whether the affinity policy should be strictly or loosely enforced";
    type enumeration {
      enum "strict";
    }
  }

  typedef live_ncs_image_state_machine_states {
    description
      "VM state machines states";
    type enumeration {
      enum "IMAGE_UNDEF_STATE";
      enum "IMAGE_CREATING_STATE";
      enum "IMAGE_ACTIVE_STATE";
      enum "IMAGE_DELETING_STATE";
      enum "IMAGE_DELETED_STATE";
      enum "IMAGE_ERROR_STATE";
    }
  }

  typedef live_ncs_flavor_state_machine_states {
    description
      "VM state machines states";
    type enumeration {
      enum "FLAVOR_UNDEF_STATE";
      enum "FLAVOR_CREATING_STATE";
      enum "FLAVOR_ACTIVE_STATE";
      enum "FLAVOR_DELETING_STATE";
      enum "FLAVOR_DELETED_STATE";
      enum "FLAVOR_ERROR_STATE";
    }
  }

  typedef live_ncs_service_state_machine_states {
    description
      "Service state machines states";
    type enumeration {
      enum "SERVICE_UNDEF_STATE";
      enum "SERVICE_DEPLOYING_STATE";
      enum "SERVICE_INERT_STATE";
      enum "SERVICE_ACTIVE_STATE";
      enum "SERVICE_UNDEPLOYING_STATE";
      enum "SERVICE_STOPPING_STATE";
      enum "SERVICE_STOPPED_STATE";
      enum "SERVICE_STARTING_STATE";
      enum "SERVICE_REBOOTING_STATE";
      enum "SERVICE_ERROR_STATE";
    }
  }

  typedef live_ncs_vm_state_machine_states {
    description
      "VM state machines states";
    type enumeration {
      enum "VM_UNDEF_STATE";
      enum "VM_DEPLOYING_STATE";
      enum "VM_MONITOR_UNSET_STATE";
      enum "VM_MONITOR_DISABLED_STATE";
      enum "VM_STOPPING_STATE";
      enum "VM_SHUTOFF_STATE";
      enum "VM_STARTING_STATE";
      enum "VM_REBOOTING_STATE";
      enum "VM_INERT_STATE";
      enum "VM_ALIVE_STATE";
      enum "VM_UNDEPLOYING_STATE";
      enum "VM_ERROR_STATE";
    }
  }

  typedef live_ncs_vm_group_properties {
    description
      "vm_group_properties";
    type enumeration {
      enum "NOTIFY_EXTERNAL_MONITOR";
    }
  }

  typedef live_ncs_action_types {
    description
      "Service/VM action types";
    type enumeration {
      enum "STOP";
      enum "START";
      enum "REBOOT";
      enum "DISABLE_MONITOR";
      enum "ENABLE_MONITOR";
      enum "DEPLOYMENT_RECOVERY";
      enum "RECOVER";
      enum "SET_MONITOR_AND_RECOVER";
    }
  }

  typedef live_ncs_vim_action_types {
    description
      "VIM connector action types";
    type enumeration {
      enum "CHECK_STATUS";
    }
  }

  typedef live_ncs_recovery_action_types {
    description
      "Recovery action types";
    type enumeration {
      enum "REBOOT_THEN_REDEPLOY";
      enum "REBOOT_ONLY";
      enum "REDEPLOY_ONLY";
    }
  }

  typedef live_ncs_recovery_style_types {
    description
      "Recovery style types";
    type enumeration {
      enum "AUTO";
      enum "MANUAL";
    }
  }

  typedef live_ncs_recovery_op_types {
    description
      "Recovery VM operation types";
    type enumeration {
      enum "DO";
      enum "DONOT";
    }
  }

  typedef live_ncs_host_action_type {
    description
      "Host action types";
    type enumeration {
      enum "ENABLE";
      enum "DISABLE";
    }
  }

  typedef live_ncs_backup_action_type {
    description
      "backup action types";
    type enumeration {
      enum "EXPORT";
      enum "SNAPSHOT";
    }
  }

  typedef live_ncs_log_level_types {
    description
      "Log levels that can be specified as part of filter in the filterLog rpc request.";
    type enumeration {
      enum "ERROR";
      enum "INFO";
      enum "WARN";
      enum "TRACE";
      enum "DEBUG";
      enum "FATAL";
    }
  }

  typedef live_ncs_log_classification_types {
    description
      "Log classifications that can be specified as part of a filter in the filterLog rpc request.";
    type enumeration {
      enum "NBI";
      enum "SBI";
      enum "SM";
      enum "MONITORING";
      enum "DYNAMIC_MAPPING";
      enum "CONFD";
      enum "CONFD_NOTIFICATION";
      enum "OS";
      enum "LIBVIRT";
      enum "VIM";
      enum "REST_EVENT";
      enum "WD";
      enum "DM";
      enum "DB";
      enum "GW";
      enum "LC";
      enum "SEC";
      enum "MOCONFIG";
      enum "POLICY";
      enum "TP";
      enum "ESC";
    }
  }

  typedef live_ncs_log_tag_types {
    description
      "Log tags that can be specified as part of a filter in the filterLog rpc request.";
    type enumeration {
      enum "wf";
      enum "eventType";
      enum "tenant";
      enum "network";
      enum "subnet";
      enum "user";
      enum "image";
      enum "flavor";
      enum "depName";
      enum "vmGrpName";
      enum "vmName";
      enum "switch";
      enum "volumeId";
      enum "svcName";
      enum "escTransactionId";
      enum "externalTenantId";
      enum "internalTenantId";
      enum "operationType";
      enum "threadName";
      enum "stateMachineContextId";
      enum "stateMachineType";
    }
  }

  typedef live_ncs_life_cycle_stage_type {
    description
      "Life-cycle stage types";
    type enumeration {
      enum "PRE_DEP";
      enum "POST_DEP";
      enum "DEP_ERROR";
      enum "PRE_UNDEP";
      enum "POST_UNDEP";
      enum "VM_RECOVERY_ERROR";
      enum "VM_RECOVERY_REDEPLOY_ERROR";
    }
  }

  typedef live_ncs_policy_condition_type {
    description
      "Policy condition types";
    type enumeration {
      enum "LCS::PRE_DEPLOY";
      enum "LCS::POST_DEPLOY_ALIVE";
      enum "LCS::DEPLOY_ERR";
      enum "LCS::POST_DEPLOY::VM_RECOVERY_ERR";
      enum "LCS::POST_DEPLOY::VM_RECOVERY_REDEPLOY_ERR";
      enum "LCS::DEPLOY::PRE_SERVICE_DEPLOY_INIT";
      enum "LCS::DEPLOY::PRE_VM_DEPLOY";
      enum "LCS::DEPLOY::POST_VM_DEPLOYED";
      enum "LCS::DEPLOY::POST_VM_DEPLOY_ERR";
      enum "LCS::DEPLOY::POST_VM_ALIVE";
      enum "LCS::DEPLOY::POST_SERVICE_DEPLOYED";
      enum "LCS::DEPLOY::POST_SERVICE_DEPLOY_ERR";
      enum "LCS::DEPLOY_UPDATE::PRE_SERVICE_UPDATE_INIT";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_DEPLOY";
      enum "LCS::DEPLOY_UPDATE::POST_VM_DEPLOYED";
      enum "LCS::DEPLOY_UPDATE::POST_VM_DEPLOY_ERR";
      enum "LCS::DEPLOY_UPDATE::POST_VM_ALIVE";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_UPDATE";
      enum "LCS::DEPLOY_UPDATE::POST_VM_UPDATED";
      enum "LCS::DEPLOY_UPDATE::POST_VM_UPDATE_ERR";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_UNDEPLOY";
      enum "LCS::DEPLOY_UPDATE::POST_VM_UNDEPLOYED";
      enum "LCS::DEPLOY_UPDATE::POST_SERVICE_UPDATED";
      enum "LCS::DEPLOY_UPDATE::POST_SERVICE_UPDATE_ERR";
      enum "LCS::UNDEPLOY::PRE_SERVICE_UNDEPLOY_INIT";
      enum "LCS::UNDEPLOY::PRE_VM_UNDEPLOY";
      enum "LCS::UNDEPLOY::POST_VM_UNDEPLOYED";
      enum "LCS::UNDEPLOY::POST_VM_UNDEPLOY_ERR";
      enum "LCS::UNDEPLOY::POST_SERVICE_UNDEPLOYED";
      enum "LCS::UNDEPLOY::POST_SERVICE_UNDEPLOY_ERR";
      enum "LCS::POST_DEPLOY::PRE_VM_RECOVERY_INIT";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_REBOOTED";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_DEPLOYED";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_COMPLETE";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_ERR";
      enum "LCS::POST_DEPLOY::PRE_VM_RECOVERY_REDEPLOY_INIT";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_REDEPLOY_DEPLOYED";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_REDEPLOY_COMPLETE";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_REDEPLOY_ERR";
      enum "LCS::VM_SCALE_OUT::PRE_VM_SCALE_OUT_INIT";
      enum "LCS::VM_SCALE_OUT::PRE_VM_DEPLOY";
      enum "LCS::VM_SCALE_OUT::POST_VM_DEPLOYED";
      enum "LCS::VM_SCALE_OUT::POST_VM_DEPLOY_ERR";
      enum "LCS::VM_SCALE_OUT::POST_VM_ALIVE";
      enum "LCS::VM_SCALE_OUT::POST_VM_SCALE_OUT_COMPLETE";
      enum "LCS::VM_SCALE_OUT::POST_VM_SCALE_OUT_ERR";
      enum "LCS::VM_SCALE_IN::PRE_VM_SCALE_IN_INIT";
      enum "LCS::VM_SCALE_IN::PRE_VM_UNDEPLOY";
      enum "LCS::VM_SCALE_IN::POST_VM_UNDEPLOYED";
      enum "LCS::VM_SCALE_IN::POST_VM_UNDEPLOY_ERR";
      enum "LCS::VM_SCALE_IN::POST_VM_SCALE_IN_COMPLETE";
      enum "LCS::VM_SCALE_IN::POST_VM_SCALE_IN_ERR";
      enum "LCS::VM::PRE_VM_DEPLOY";
      enum "LCS::VM::POST_VM_DEPLOYED";
      enum "LCS::VM::POST_VM_DEPLOY_ERR";
      enum "LCS::VM::POST_VM_ALIVE";
      enum "LCS::VM::PRE_VM_UNDEPLOY";
      enum "LCS::VM::POST_VM_UNDEPLOYED";
      enum "LCS::VM::POST_VM_UNDEPLOY_ERR";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_SOFTWARE_VERSION_UPDATE";
      enum "LCS::DEPLOY_UPDATE::POST_VM_SOFTWARE_VERSION_UPDATED";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_VOLUME_DETACH";
      enum "LCS::DEPLOY_UPDATE::POST_VM_VOLUME_DETACHED";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_VOLUME_ATTACH";
      enum "LCS::DEPLOY_UPDATE::POST_VM_VOLUME_ATTACHED";
    }
  }

  typedef live_ncs_template_engine_type {
    description
      "Config data (template file) template engine type";
    type enumeration {
      enum "VELOCITY";
      enum "NONE";
    }
  }

  typedef live_ncs_vim_type {
    description
      "Vim types";
    type enumeration {
      enum "OPENSTACK";
      enum "LIBVIRT";
      enum "VMWARE_VSPHERE";
      enum "AWS_EC2";
      enum "CSP";
      enum "KUBERNETES";
      enum "VMWARE_VCD";
      enum "CCP";
      enum "DOCKER";
    }
  }

  typedef live_ncs_migrateAction {
    description
      "migrate Action";
    type enumeration {
      enum "enabledpdk";
    }
  }

  typedef live_ncs_host_location_type {
    description
      "host location path";
    type string {
      pattern '[a-zA-Z0-9:.\-_]*';
      length "1..256";
    }
  }

  typedef live_ncs_checksum_type {
    description
      "Algorithm to use to validate the image checksum";
    type enumeration {
      enum "sha256sum";
      enum "sha512sum";
    }
  }

  typedef live_ncs_file_persistence_type {
    description
      "Options for what to do with the file post operations";
    type enumeration {
      enum "CACHE" {
        description
          "Keep local copy";
      }
      enum "FETCH_ALWAYS" {
        description
          "Fetch file each time it is used";
      }
      enum "FETCH_MISSING" {
        description
          "Use local copy or fetch if missing";
      }
    }
  }

  typedef live_ncs_checksum_algorithm_type {
    description
      "Supported algorithms for checksum validation";
    type enumeration {
      enum "MD5";
      enum "SHA1";
      enum "SHA224";
      enum "SHA256";
      enum "SHA384";
      enum "SHA512";
    }
  }

  typedef live_ncs_service_type {
    description
      "Kubernetes Service types";
    type enumeration {
      enum "LoadBalancer";
      enum "ClusterIP";
      enum "NodePort";
    }
    // NCS drop default statement
  }

  typedef live_ncs_config_data_format_type {
    description
      "Options for processing config data";
    type enumeration {
      enum "CREATE_ISO" {
        description
          "Create an ISO file using the files provided and upload to VM";
      }
      enum "CONFIG_DATA_OPTIONS" {
        description
          "Config data options like additional day-0 configurations";
      }
    }
  }

  typedef live_ncs_import_action_types {
    description
      "ImportDeploymentData action types";
    type enumeration {
      enum "CREATE";
      enum "DELETE";
      enum "GET";
      enum "FINALIZE";
    }
  }

  typedef live_ncs_uri {
    type string;
    description
      "The uri type represents a Uniform Resource Identifier
       (URI) as defined by STD 66.

       Objects using the uri type MUST be in US-ASCII encoding,
       and MUST be normalized as described by RFC 3986 Sections
       6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary
       percent-encoding is removed, and all case-insensitive
       characters are set to lowercase except for hexadecimal
       digits, which are normalized to uppercase as described in
       Section 6.2.2.1.

       The purpose of this normalization is to help provide
       unique URIs.  Note that this normalization is not
       sufficient to provide uniqueness.  Two URIs that are
       textually distinct after this normalization may still be
       equivalent.

       Objects using the uri type may restrict the schemes that
       they permit.  For example, 'data:' and 'urn:' schemes
       might not be appropriate.

       A zero-length URI is not a valid URI.  This can be used to
       express 'URI absent' where required.

       In the value set and its semantics, this type is equivalent
       to the Uri SMIv2 textual convention defined in RFC 5017.";
    reference
      "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax
       RFC 3305: Report from the Joint W3C/IETF URI Planning Interest
          Group: Uniform Resource Identifiers (URIs), URLs,
          and Uniform Resource Names (URNs): Clarifications
          and Recommendations
       RFC 5017: MIB Textual Conventions for Uniform Resource
          Identifiers (URIs)";
  }

  typedef escfloat {
    type string;
    reference "http://www.w3.org/TR/xmlschema-2/#float";
  }

  typedef escname {
    type string {
      length "1..256";
    }
  }

  typedef escversion {
    type string {
      length "1..16";
    }
  }

  typedef escnetname {
    type string {
      length "1..255";
    }
  }

  typedef escbigdata {
    type string {
      length "1..16384";
    }
  }

  typedef escipaddr {
    type ietf-inet-types:ip-address;
  }

  typedef esc_ip_prefix {
    type string {
      pattern '(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8]))';
    }
  }

  typedef escmacaddr {
    type ietf-yang-types:mac-address;
  }

  typedef license_key_type {
    type enumeration {
      enum "mac_addr";
    }
  }

  typedef license_key_value {
    type string {
      length "1..256";
    }
  }

  typedef event_types {
    type enumeration {
      enum "CREATE_NETWORK";
      enum "DELETE_NETWORK";
      enum "CREATE_SUBNET";
      enum "DELETE_SUBNET";
      enum "CREATE_TENANT";
      enum "DELETE_TENANT";
      enum "CREATE_IMAGE";
      enum "DELETE_IMAGE";
      enum "CREATE_FLAVOR";
      enum "DELETE_FLAVOR";
      enum "VM_DEPLOYED";
      enum "VM_ALIVE";
      enum "VM_UPDATED";
      enum "VM_UNDEPLOYED";
      enum "SERVICE_ALIVE";
      enum "SERVICE_UNDEPLOYED";
      enum "VM_SCALE_OUT_INIT";
      enum "VM_SCALE_OUT_DEPLOYED";
      enum "VM_SCALE_OUT_COMPLETE";
      enum "VM_SCALE_IN_INIT";
      enum "VM_SCALE_IN_COMPLETE";
      enum "VM_RECOVERY_INIT";
      enum "VM_RECOVERY_DEPLOYED";
      enum "VM_RECOVERY_UNDEPLOYED";
      enum "VM_RECOVERY_COMPLETE";
      enum "SERVICE_UPDATED";
      enum "VM_STOPPED";
      enum "SERVICE_STOPPED";
      enum "VM_STARTED";
      enum "SERVICE_STARTED";
      enum "VM_REBOOTED";
      enum "SERVICE_REBOOTED";
      enum "VM_MONITOR_UNSET";
      enum "SERVICE_MONITOR_UNSET";
      enum "VM_MONITOR_SET";
      enum "VIM_OPERATIONAL_STATE";
      enum "VM_RECOVERY_CANCELLED";
      enum "VM_RECOVERY_REBOOT";
      enum "HOST_ENABLE";
      enum "HOST_DISABLE";
      enum "VM_MANUAL_RECOVERY_NEEDED";
      enum "VM_MANUAL_RECOVERY_NO_NEED";
      enum "CREATE_VIM_CONNECTOR";
      enum "DELETE_VIM_CONNECTOR";
      enum "UPDATE_VIM_CONNECTOR";
      enum "CREATE_VIM_USER";
      enum "DELETE_VIM_USER";
      enum "UPDATE_VIM_USER";
      enum "VM_SOFTWARE_VERSION_UPDATED";
      enum "LCS_NOTIFY";
      enum "CREATE_VOLUME";
      enum "DELETE_VOLUME";
      enum "VM_BACKUP_INIT";
      enum "VM_BACKUP_CREATED";
      enum "VM_BACKUP_COMPLETE";
      enum "CREATE_DEFAULT_VIM_CONNECTOR";
      enum "DELETE_DEFAULT_VIM_CONNECTOR";
      enum "UPDATE_DEFAULT_VIM_CONNECTOR";
      enum "VIM_CONNECTION_STATE";
      enum "SERVICE_RECOVERY_COMPLETE";
      enum "CREATE_FILE_SERVER";
      enum "UPDATE_FILE_SERVER";
      enum "DELETE_FILE_SERVER";
      enum "VM_NETWORK_STATE";
      enum "UPDATE_TENANT";
      enum "VM_OVERLOADED";
      enum "VM_UNDERLOADED";
      enum "VM_MONITORING_STATUS";
      enum "POLICY_ACTION_UPDATE";
      enum "VM_ACTION_BLOCKED";
      enum "SUBNET_UPDATED";
      enum "VM_MIGRATE_INIT";
      enum "VM_MIGRATED";
      enum "VM_MIGRATE_COMPLETE";
      enum "IMAGE_UPDATED";
      enum "EXPORT_IMAGE_FLAVOR";
      enum "IMPORT_IMAGE_FLAVOR";
      enum "UPDATE_CONFIG_PARAM";
      enum "DELETE_CONFIG_PARAM";
      enum "IMPORT_VM";
      enum "UPDATE_FLAVOR";
    }
  }

  typedef status {
    type enumeration {
      enum "SUCCESS";
      enum "FAILURE";
    }
  }

  typedef szunits {
    description
      "Some standard size units: MiB, GiB, TiB and PiB
              MiB: 1024^2 (Mebibyte)
              GiB: 1024^3 (Gibibyte)
              TiB: 1024^4 (Tebibyte)
              PiB: 1024^5 (Pebibyte)";
    type enumeration {
      enum "MiB";
      enum "GiB";
      enum "TiB";
      enum "PiB";
    }
  }

  typedef iobus {
    description
      "PCI bus interface that is to be used while attaching the OS
       disk to the domain. Currently supported bus types are IDE,
       SCSI and VIRTIO";
    type enumeration {
      enum "ide";
      enum "scsi";
      enum "virtio";
    }
  }

  typedef iface_type {
    description
      "Interface Type: VIRTUAL/PASSTHRU";
    type enumeration {
      enum "virtual";
      enum "passthru";
      enum "direct";
      enum "macvtap";
      enum "access";
      enum "trunk";
    }
  }

  typedef iface_model {
    description
      "Virtual Interface Type: virtio, e1000 etc. Later when we support
       'passthru' interface type we can change this to a union";
    type enumeration {
      enum "e1000";
      enum "ne2k_pci";
      enum "virtio";
      enum "i82551";
      enum "i82557b";
      enum "i82559er";
      enum "rtl8139";
      enum "pcnet";
    }
  }

  typedef ipversion_t {
    description
      "ipv4 or ipv6";
    type enumeration {
      enum "ipv4";
      enum "ipv6";
    }
  }

  typedef ipprotocol_t {
    description
      "TCP or UDP";
    type enumeration {
      enum "TCP";
      enum "UDP";
    }
  }

  typedef disk_formats {
    description
      "The format of the disk that is being specified as disk source.
       Currently QCOW2, RAW and VMDK formats are supported.";
    type enumeration {
      enum "qcow2";
      enum "raw";
      enum "vmdk";
    }
  }

  typedef device_type {
    description
      "The type of device to be attached to the VM.
       Currently disk and cdrom are supported.";
    type enumeration {
      enum "disk";
      enum "cdrom";
    }
  }

  typedef conditions {
    description
      "Different conditions supported with respect to metric comparison";
    type enumeration {
      enum "GT";
      enum "LT";
      enum "EQ";
      enum "GE";
      enum "LE";
    }
  }

  typedef metric_types {
    description
      "Different conditions supported with respect to metric comparison";
    type enumeration {
      enum "INT8";
      enum "INT16";
      enum "INT32";
      enum "UINT8";
      enum "UINT16";
      enum "UINT32";
      enum "FLOAT";
      enum "DOUBLE";
    }
  }

  typedef pollunits {
    description
      "Polling units, seconds or minutes";
    type enumeration {
      enum "minutes";
      enum "seconds";
    }
  }

  typedef wd_hardware {
    description
      "Only certain Watchdog hardware are supported current.";
    type enumeration {
      enum "i6300esb";
      enum "ib700";
    }
  }

  typedef wd_action {
    description
      "Action that should be taken by the hypervisor when watchdog
       is triggered";
    type enumeration {
      enum "reset";
      enum "poweroff";
      enum "shutdown";
      enum "pasue";
      enum "debug";
      enum "none";
    }
  }

  typedef placement_type {
    description
      "Whether VMs of two groups to be place together (affinity) or on separate
       hosts (anti_affinity), also whether VMs should be placed on a host or in a zone";
    type enumeration {
      enum "affinity";
      enum "anti_affinity";
      enum "zone_host";
    }
  }

  typedef enforcement {
    description
      "Whether the affinity policy should be strictly or loosely enforced";
    type enumeration {
      enum "strict";
    }
  }

  typedef image_state_machine_states {
    description
      "VM state machines states";
    type enumeration {
      enum "IMAGE_UNDEF_STATE";
      enum "IMAGE_CREATING_STATE";
      enum "IMAGE_ACTIVE_STATE";
      enum "IMAGE_DELETING_STATE";
      enum "IMAGE_DELETED_STATE";
      enum "IMAGE_ERROR_STATE";
    }
  }

  typedef flavor_state_machine_states {
    description
      "VM state machines states";
    type enumeration {
      enum "FLAVOR_UNDEF_STATE";
      enum "FLAVOR_CREATING_STATE";
      enum "FLAVOR_ACTIVE_STATE";
      enum "FLAVOR_DELETING_STATE";
      enum "FLAVOR_DELETED_STATE";
      enum "FLAVOR_ERROR_STATE";
    }
  }

  typedef service_state_machine_states {
    description
      "Service state machines states";
    type enumeration {
      enum "SERVICE_UNDEF_STATE";
      enum "SERVICE_DEPLOYING_STATE";
      enum "SERVICE_INERT_STATE";
      enum "SERVICE_ACTIVE_STATE";
      enum "SERVICE_UNDEPLOYING_STATE";
      enum "SERVICE_STOPPING_STATE";
      enum "SERVICE_STOPPED_STATE";
      enum "SERVICE_STARTING_STATE";
      enum "SERVICE_REBOOTING_STATE";
      enum "SERVICE_ERROR_STATE";
    }
  }

  typedef vm_state_machine_states {
    description
      "VM state machines states";
    type enumeration {
      enum "VM_UNDEF_STATE";
      enum "VM_DEPLOYING_STATE";
      enum "VM_MONITOR_UNSET_STATE";
      enum "VM_MONITOR_DISABLED_STATE";
      enum "VM_STOPPING_STATE";
      enum "VM_SHUTOFF_STATE";
      enum "VM_STARTING_STATE";
      enum "VM_REBOOTING_STATE";
      enum "VM_INERT_STATE";
      enum "VM_ALIVE_STATE";
      enum "VM_UNDEPLOYING_STATE";
      enum "VM_ERROR_STATE";
    }
  }

  typedef vm_group_properties {
    description
      "vm_group_properties";
    type enumeration {
      enum "NOTIFY_EXTERNAL_MONITOR";
    }
  }

  typedef action_types {
    description
      "Service/VM action types";
    type enumeration {
      enum "STOP";
      enum "START";
      enum "REBOOT";
      enum "DISABLE_MONITOR";
      enum "ENABLE_MONITOR";
      enum "DEPLOYMENT_RECOVERY";
      enum "RECOVER";
      enum "SET_MONITOR_AND_RECOVER";
    }
  }

  typedef vim_action_types {
    description
      "VIM connector action types";
    type enumeration {
      enum "CHECK_STATUS";
    }
  }

  typedef recovery_action_types {
    description
      "Recovery action types";
    type enumeration {
      enum "REBOOT_THEN_REDEPLOY";
      enum "REBOOT_ONLY";
      enum "REDEPLOY_ONLY";
    }
  }

  typedef recovery_style_types {
    description
      "Recovery style types";
    type enumeration {
      enum "AUTO";
      enum "MANUAL";
    }
  }

  typedef recovery_op_types {
    description
      "Recovery VM operation types";
    type enumeration {
      enum "DO";
      enum "DONOT";
    }
  }

  typedef host_action_type {
    description
      "Host action types";
    type enumeration {
      enum "ENABLE";
      enum "DISABLE";
    }
  }

  typedef backup_action_type {
    description
      "backup action types";
    type enumeration {
      enum "EXPORT";
      enum "SNAPSHOT";
    }
  }

  typedef log_level_types {
    description
      "Log levels that can be specified as part of filter in the filterLog rpc request.";
    type enumeration {
      enum "ERROR";
      enum "INFO";
      enum "WARN";
      enum "TRACE";
      enum "DEBUG";
      enum "FATAL";
    }
  }

  typedef log_classification_types {
    description
      "Log classifications that can be specified as part of a filter in the filterLog rpc request.";
    type enumeration {
      enum "NBI";
      enum "SBI";
      enum "SM";
      enum "MONITORING";
      enum "DYNAMIC_MAPPING";
      enum "CONFD";
      enum "CONFD_NOTIFICATION";
      enum "OS";
      enum "LIBVIRT";
      enum "VIM";
      enum "REST_EVENT";
      enum "WD";
      enum "DM";
      enum "DB";
      enum "GW";
      enum "LC";
      enum "SEC";
      enum "MOCONFIG";
      enum "POLICY";
      enum "TP";
      enum "ESC";
    }
  }

  typedef log_tag_types {
    description
      "Log tags that can be specified as part of a filter in the filterLog rpc request.";
    type enumeration {
      enum "wf";
      enum "eventType";
      enum "tenant";
      enum "network";
      enum "subnet";
      enum "user";
      enum "image";
      enum "flavor";
      enum "depName";
      enum "vmGrpName";
      enum "vmName";
      enum "switch";
      enum "volumeId";
      enum "svcName";
      enum "escTransactionId";
      enum "externalTenantId";
      enum "internalTenantId";
      enum "operationType";
      enum "threadName";
      enum "stateMachineContextId";
      enum "stateMachineType";
    }
  }

  typedef life_cycle_stage_type {
    description
      "Life-cycle stage types";
    type enumeration {
      enum "PRE_DEP";
      enum "POST_DEP";
      enum "DEP_ERROR";
      enum "PRE_UNDEP";
      enum "POST_UNDEP";
      enum "VM_RECOVERY_ERROR";
      enum "VM_RECOVERY_REDEPLOY_ERROR";
    }
  }

  typedef policy_condition_type {
    description
      "Policy condition types";
    type enumeration {
      enum "LCS::PRE_DEPLOY";
      enum "LCS::POST_DEPLOY_ALIVE";
      enum "LCS::DEPLOY_ERR";
      enum "LCS::POST_DEPLOY::VM_RECOVERY_ERR";
      enum "LCS::POST_DEPLOY::VM_RECOVERY_REDEPLOY_ERR";
      enum "LCS::DEPLOY::PRE_SERVICE_DEPLOY_INIT";
      enum "LCS::DEPLOY::PRE_VM_DEPLOY";
      enum "LCS::DEPLOY::POST_VM_DEPLOYED";
      enum "LCS::DEPLOY::POST_VM_DEPLOY_ERR";
      enum "LCS::DEPLOY::POST_VM_ALIVE";
      enum "LCS::DEPLOY::POST_SERVICE_DEPLOYED";
      enum "LCS::DEPLOY::POST_SERVICE_DEPLOY_ERR";
      enum "LCS::DEPLOY_UPDATE::PRE_SERVICE_UPDATE_INIT";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_DEPLOY";
      enum "LCS::DEPLOY_UPDATE::POST_VM_DEPLOYED";
      enum "LCS::DEPLOY_UPDATE::POST_VM_DEPLOY_ERR";
      enum "LCS::DEPLOY_UPDATE::POST_VM_ALIVE";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_UPDATE";
      enum "LCS::DEPLOY_UPDATE::POST_VM_UPDATED";
      enum "LCS::DEPLOY_UPDATE::POST_VM_UPDATE_ERR";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_UNDEPLOY";
      enum "LCS::DEPLOY_UPDATE::POST_VM_UNDEPLOYED";
      enum "LCS::DEPLOY_UPDATE::POST_SERVICE_UPDATED";
      enum "LCS::DEPLOY_UPDATE::POST_SERVICE_UPDATE_ERR";
      enum "LCS::UNDEPLOY::PRE_SERVICE_UNDEPLOY_INIT";
      enum "LCS::UNDEPLOY::PRE_VM_UNDEPLOY";
      enum "LCS::UNDEPLOY::POST_VM_UNDEPLOYED";
      enum "LCS::UNDEPLOY::POST_VM_UNDEPLOY_ERR";
      enum "LCS::UNDEPLOY::POST_SERVICE_UNDEPLOYED";
      enum "LCS::UNDEPLOY::POST_SERVICE_UNDEPLOY_ERR";
      enum "LCS::POST_DEPLOY::PRE_VM_RECOVERY_INIT";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_REBOOTED";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_DEPLOYED";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_COMPLETE";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_ERR";
      enum "LCS::POST_DEPLOY::PRE_VM_RECOVERY_REDEPLOY_INIT";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_REDEPLOY_DEPLOYED";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_REDEPLOY_COMPLETE";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_REDEPLOY_ERR";
      enum "LCS::VM_SCALE_OUT::PRE_VM_SCALE_OUT_INIT";
      enum "LCS::VM_SCALE_OUT::PRE_VM_DEPLOY";
      enum "LCS::VM_SCALE_OUT::POST_VM_DEPLOYED";
      enum "LCS::VM_SCALE_OUT::POST_VM_DEPLOY_ERR";
      enum "LCS::VM_SCALE_OUT::POST_VM_ALIVE";
      enum "LCS::VM_SCALE_OUT::POST_VM_SCALE_OUT_COMPLETE";
      enum "LCS::VM_SCALE_OUT::POST_VM_SCALE_OUT_ERR";
      enum "LCS::VM_SCALE_IN::PRE_VM_SCALE_IN_INIT";
      enum "LCS::VM_SCALE_IN::PRE_VM_UNDEPLOY";
      enum "LCS::VM_SCALE_IN::POST_VM_UNDEPLOYED";
      enum "LCS::VM_SCALE_IN::POST_VM_UNDEPLOY_ERR";
      enum "LCS::VM_SCALE_IN::POST_VM_SCALE_IN_COMPLETE";
      enum "LCS::VM_SCALE_IN::POST_VM_SCALE_IN_ERR";
      enum "LCS::VM::PRE_VM_DEPLOY";
      enum "LCS::VM::POST_VM_DEPLOYED";
      enum "LCS::VM::POST_VM_DEPLOY_ERR";
      enum "LCS::VM::POST_VM_ALIVE";
      enum "LCS::VM::PRE_VM_UNDEPLOY";
      enum "LCS::VM::POST_VM_UNDEPLOYED";
      enum "LCS::VM::POST_VM_UNDEPLOY_ERR";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_SOFTWARE_VERSION_UPDATE";
      enum "LCS::DEPLOY_UPDATE::POST_VM_SOFTWARE_VERSION_UPDATED";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_VOLUME_DETACH";
      enum "LCS::DEPLOY_UPDATE::POST_VM_VOLUME_DETACHED";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_VOLUME_ATTACH";
      enum "LCS::DEPLOY_UPDATE::POST_VM_VOLUME_ATTACHED";
    }
  }

  typedef template_engine_type {
    description
      "Config data (template file) template engine type";
    type enumeration {
      enum "VELOCITY";
      enum "NONE";
    }
  }

  typedef vim_type {
    description
      "Vim types";
    type enumeration {
      enum "OPENSTACK";
      enum "LIBVIRT";
      enum "VMWARE_VSPHERE";
      enum "AWS_EC2";
      enum "CSP";
      enum "KUBERNETES";
      enum "VMWARE_VCD";
      enum "CCP";
      enum "DOCKER";
    }
  }

  typedef migrateAction {
    description
      "migrate Action";
    type enumeration {
      enum "enabledpdk";
    }
  }

  typedef host_location_type {
    description
      "host location path";
    type string {
      pattern '[a-zA-Z0-9:.\-_]*';
      length "1..256";
    }
  }

  typedef checksum_type {
    description
      "Algorithm to use to validate the image checksum";
    type enumeration {
      enum "sha256sum";
      enum "sha512sum";
    }
  }

  typedef file_persistence_type {
    description
      "Options for what to do with the file post operations";
    type enumeration {
      enum "CACHE" {
        description
          "Keep local copy";
      }
      enum "FETCH_ALWAYS" {
        description
          "Fetch file each time it is used";
      }
      enum "FETCH_MISSING" {
        description
          "Use local copy or fetch if missing";
      }
    }
  }

  typedef checksum_algorithm_type {
    description
      "Supported algorithms for checksum validation";
    type enumeration {
      enum "MD5";
      enum "SHA1";
      enum "SHA224";
      enum "SHA256";
      enum "SHA384";
      enum "SHA512";
    }
  }

  typedef service_type {
    description
      "Kubernetes Service types";
    type enumeration {
      enum "LoadBalancer";
      enum "ClusterIP";
      enum "NodePort";
    }
    default "ClusterIP";
  }

  typedef config_data_format_type {
    description
      "Options for processing config data";
    type enumeration {
      enum "CREATE_ISO" {
        description
          "Create an ISO file using the files provided and upload to VM";
      }
      enum "CONFIG_DATA_OPTIONS" {
        description
          "Config data options like additional day-0 configurations";
      }
    }
  }

  typedef import_action_types {
    description
      "ImportDeploymentData action types";
    type enumeration {
      enum "CREATE";
      enum "DELETE";
      enum "GET";
      enum "FINALIZE";
    }
  }

  typedef uri {
    type string;
    description
      "The uri type represents a Uniform Resource Identifier
       (URI) as defined by STD 66.

       Objects using the uri type MUST be in US-ASCII encoding,
       and MUST be normalized as described by RFC 3986 Sections
       6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary
       percent-encoding is removed, and all case-insensitive
       characters are set to lowercase except for hexadecimal
       digits, which are normalized to uppercase as described in
       Section 6.2.2.1.

       The purpose of this normalization is to help provide
       unique URIs.  Note that this normalization is not
       sufficient to provide uniqueness.  Two URIs that are
       textually distinct after this normalization may still be
       equivalent.

       Objects using the uri type may restrict the schemes that
       they permit.  For example, 'data:' and 'urn:' schemes
       might not be appropriate.

       A zero-length URI is not a valid URI.  This can be used to
       express 'URI absent' where required.

       In the value set and its semantics, this type is equivalent
       to the Uri SMIv2 textual convention defined in RFC 5017.";
    reference
      "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax
       RFC 3305: Report from the Joint W3C/IETF URI Planning Interest
          Group: Uniform Resource Identifiers (URIs), URLs,
          and Uniform Resource Names (URNs): Clarifications
          and Recommendations
       RFC 5017: MIB Textual Conventions for Uniform Resource
          Identifiers (URIs)";
  }
}
